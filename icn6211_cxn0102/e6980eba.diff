From e6980ebaade6018ff56db6c098cef91f797dbe2b Mon Sep 17 00:00:00 2001
From: shaomingliang <shaomingliang@meigsmart.com>
Date: Tue, 20 Dec 2016 14:51:20 +0800
Subject: [PATCH] [BugID]5644 [SNT132][Description]support icn6211 & cxn0102

Change-Id: Ia108953ad56f181d32496cdcaa2ffca64c210139
---

diff --git a/bootable/bootloader/lk/target/msm8916/rules.mk b/bootable/bootloader/lk/target/msm8916/rules.mk
old mode 100644
new mode 100755
index 6acddef..c7ee1a9
--- a/bootable/bootloader/lk/target/msm8916/rules.mk
+++ b/bootable/bootloader/lk/target/msm8916/rules.mk
@@ -11,7 +11,7 @@
 BASE_ADDR        := 0x80000000
 SCRATCH_ADDR     := 0x90000000
 
-DEFINES += DISPLAY_SPLASH_SCREEN=1
+DEFINES += DISPLAY_SPLASH_SCREEN=0
 DEFINES += DISPLAY_TYPE_MIPI=1
 DEFINES += DISPLAY_TYPE_DSI6G=1
 
diff --git a/kernel/arch/arm/boot/dts/qcom/dsi-mipi-2-rgb_1280p_video.dtsi b/kernel/arch/arm/boot/dts/qcom/dsi-mipi-2-rgb_1280p_video.dtsi
new file mode 100755
index 0000000..7368054
--- /dev/null
+++ b/kernel/arch/arm/boot/dts/qcom/dsi-mipi-2-rgb_1280p_video.dtsi
@@ -0,0 +1,75 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_mipi_rgb_1280p_video: qcom,mdss_dsi_mipi_rgb_1280p_video {
+		qcom,mdss-dsi-panel-name = "icn6211 mipi rgb 1280x720 video";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <1280>;
+		qcom,mdss-dsi-panel-height = <720>;
+		qcom,mdss-dsi-h-front-porch = <110>;
+		qcom,mdss-dsi-h-back-porch = <220>;
+		qcom,mdss-dsi-h-pulse-width = <40>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <20>;
+		qcom,mdss-dsi-v-front-porch = <5>;
+		qcom,mdss-dsi-v-pulse-width = <5>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = "rgb_swap_rgb";
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-pixel-packing = "tight";
+		qcom,mdss-dsi-pixel-alignment = <0>;
+		qcom,mdss-command-access = "i2c";
+		qcom,mdss-dsi-on-command = [				
+					05 01 00 00 78 00 02 11 00
+					05 01 00 00 14 00 02 29 00];
+		qcom,mdss-dsi-off-command = [05 01 00 00 32 00 02 28 00
+					05 01 00 00 78 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <0>;
+		qcom,mdss-dsi-traffic-mode = "non_burst_sync_event";
+		qcom,mdss-dsi-lane-map = "lane_map_0123";
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [7F 1C 12 00 40 44 16 1E 17 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x04>;
+		qcom,mdss-dsi-t-clk-pre = <0x27>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <255>;
+		qcom,mdss-dsi-dma-trigger = "trigger_sw";
+		qcom,mdss-dsi-mdp-trigger = "none";
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_pwm";
+		qcom,mdss-dsi-reset-sequence = <0 50>, <1 150>;//no use
+		qcom,mdss-dsi-force-clock-lane-hs;
+		qcom,mdss-dsi-always-on;
+	};
+};
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8916-camera-sensor-qrd-skui.dtsi b/kernel/arch/arm/boot/dts/qcom/msm8916-camera-sensor-qrd-skui.dtsi
index df94953..384f7f7 100755
--- a/kernel/arch/arm/boot/dts/qcom/msm8916-camera-sensor-qrd-skui.dtsi
+++ b/kernel/arch/arm/boot/dts/qcom/msm8916-camera-sensor-qrd-skui.dtsi
@@ -13,7 +13,7 @@
 
 &tlmm_pinmux {
 	SGM3780_pins {                          /* Modify OCP8110-->SGM3780 by huangfusheng 2016-06-06 */
-		qcom,pins = <&gp 51>, <&gp 31>;
+		qcom,pins = <&gp 100>, <&gp 31>;
 		qcom,num-grp-pins = <2>;
 		qcom,pin-func = <0>;
 		label = "SGM3780_pins";
@@ -30,7 +30,7 @@
 		status = "okay";
 		pinctrl-names = "flash_default";
 		pinctrl-0 = <&SGM3780_default>;
-		qcom,flash-en = <&msm_gpio 51 0>;
+		qcom,flash-en = <&msm_gpio 100 0>;
 		qcom,flash-now = <&msm_gpio 31 0>;
 		qcom,op-seq = "flash_en", "flash_now";
 		qcom,torch-seq-val = <1 0>;
@@ -154,7 +154,7 @@
 			<&msm_gpio 34 0>,
 			<&msm_gpio 120 0>,
 			<&msm_gpio 28 0>,       /* Add Rear Camera DVDD enable by huangfusheng 2016-12-17 */
-			<&msm_gpio 51 0>;       /* Add Rear Camera AVDD enable by huangfusheng 2016-12-17 */
+			<&msm_gpio 62 0>;       /* Add Rear Camera VAF VDD enable by huangfusheng 2016-11-15 */
 		qcom,gpio-reset = <1>;
 		qcom,gpio-standby = <2>;
 		qcom,gpio-af-pwdm = <3>;
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8916-pinctrl.dtsi b/kernel/arch/arm/boot/dts/qcom/msm8916-pinctrl.dtsi
index 15dab8f..8f4f24f 100755
--- a/kernel/arch/arm/boot/dts/qcom/msm8916-pinctrl.dtsi
+++ b/kernel/arch/arm/boot/dts/qcom/msm8916-pinctrl.dtsi
@@ -137,6 +137,21 @@
 				bias-pull-down;
 			};
 		};
+		/* add icn6211 driver elio shao */
+		icn6211_reset_pin {
+			qcom,pins = <&gp 21>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "icn6211_reset_pin";
+			icn_default: icn_default {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+			icn_sleep: icn_sleep {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
 		cross-conn-det {
 			qcom,pins = <&gp 120>;
 			qcom,num-grp-pins = <1>;
@@ -1086,7 +1101,7 @@
 		};
 
 		tpiu_setb_13 {
-			qcom,pins = <&gp 36>;
+			qcom,pins = <&gp 116>;
 			qcom,num-grp-pins = <1>;
 			qcom,pin-func = <8>;
 			label = "tpiu-setb-13";
@@ -1179,19 +1194,20 @@
 
 		/* add pingrp for touchscreen */
 		pmx_ts_int_active {
-			qcom,pins = <&gp 13>;
+			qcom,pins = <&gp 36>;
 			qcom,pin-func = <0>;
 			qcom,num-grp-pins = <1>;
 			label = "pmx_ts_int_active";
 
 			ts_int_active: ts_int_active {
 				drive-strength = <16>;
-				bias-pull-up;
+				//bias-pull-up;
+				bias-disable;
 			};
 		};
 
 		pmx_ts_int_suspend {
-			qcom,pins = <&gp 13>;
+			qcom,pins = <&gp 36>;
 			qcom,pin-func = <0>;
 			qcom,num-grp-pins = <1>;
 			label = "pmx_ts_int_suspend";
@@ -1203,7 +1219,7 @@
 		};
 
 		pmx_ts_reset_active {
-			qcom,pins = <&gp 12>;
+			qcom,pins = <&gp 25>;
 			qcom,pin-func = <0>;
 			qcom,num-grp-pins = <1>;
 			label = "pmx_ts_reset_active";
@@ -1215,7 +1231,7 @@
 		};
 
 		pmx_ts_reset_suspend {
-			qcom,pins = <&gp 12>;
+			qcom,pins = <&gp 25>;
 			qcom,pin-func = <0>;
 			qcom,num-grp-pins = <1>;
 			label = "pmx_ts_reset_suspend";
@@ -1359,7 +1375,7 @@
 
 		cam_sensor_flash {
 			/* FLASH_RESET,FLASH_EN,FLASH_NOW */
-			qcom,pins = <&gp 36>, <&gp 31>,<&gp 32> ;
+			qcom,pins = <&gp 115>, <&gp 31>,<&gp 32> ;
 			qcom,num-grp-pins = <3>;
 			qcom,pin-func = <0>;
 			label = "cam_sensor_flash";
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dts b/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dts
index 3dcd488..4fad355 100755
--- a/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dts
+++ b/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dts
@@ -22,6 +22,20 @@
 };
 
 &soc {
+	i2c@78b6000{
+			cxn0102@77 {
+				compatible = "qcom,cxn0102";
+				reg = <0x77>;
+				interrupt-parent = <&msm_gpio>;
+        interrupts = <36 1>;
+        cxn-reset-gpios = <&msm_gpio 25 0x00>;
+        cxn-interrupt-gpios = <&msm_gpio 36 0x00>;
+        vdd-supply = <&pm8916_l6>;
+        pinctrl-names = "pmx_ts_active","pmx_ts_suspend";
+        pinctrl-0 = <&ts_int_active &ts_reset_active>;
+        pinctrl-1 = <&ts_int_suspend &ts_reset_suspend>;			
+		};
+	};
 	i2c@78b8000 {
 		smb1360_otg_supply: smb1360-chg-fg@14 {
 			compatible = "qcom,smb1360-chg-fg";
@@ -51,71 +65,18 @@
 	};
 
 
-	i2c@78b9000 { // BLSP1 QUP5
-
-/* rm by huangfusheng 2016-12-19 */
-/*
-		goodix@5d {
-            compatible = "goodix,gt9xx";
-            reg = <0x5d>;
-            interrupt-parent = <&msm_gpio>;
-            interrupts = <13 0x2008>;
-            reset-gpios = <&msm_gpio 12 0x00>;
-            interrupt-gpios = <&msm_gpio 13 0x00>;
-            vdd-supply = <&pm8916_l17>;
-            vcc-i2c-supply = <&pm8916_l6>;
-            goodix,button-map = <139 102 158>;
-            goodix,panel-coords = <0 0 720 1200>;
-            goodix,display-coords = <0 0 720 1080>;
-            goodix,product-id = "9157";
-            goodix,num_max_touches = <5>;
-            goodix,soft_rst_dly = <20>;
-            goodix,fw_name = "gtp_fw.bin";
-            goodix,fw-vkey-support;
-            goodix,i2c-pull-up;
-            goodix,no-force-update;
-            pinctrl-names = "pmx_ts_active","pmx_ts_suspend","pmx_ts_release";
-            pinctrl-0 = <&ts_int_active &ts_reset_active>;
-            pinctrl-1 = <&ts_int_suspend &ts_reset_suspend>;
-            pinctrl-2 = <&ts_release>;
-        };
-*/
-
-/*
-		focaltech@38 {
-			compatible = "focaltech,5x06";
-			reg = <0x38>;
-			interrupt-parent = <&msm_gpio>;
-			interrupts = <13 0x2>;
-			vdd-supply = <&pm8916_l17>;
-			vcc_i2c-supply = <&pm8916_l6>;
-			pinctrl-names = "pmx_ts_active","pmx_ts_suspend","pmx_ts_release";
-			pinctrl-0 = <&ts_int_active &ts_reset_active>;
-			pinctrl-1 = <&ts_int_suspend &ts_reset_suspend>;
-			pinctrl-2 = <&ts_release>;
-			focaltech,name = "ft6436";
-			focaltech,family-id = <0x36>;
-			focaltech,reset-gpio = <&msm_gpio 12 0x0>;
-			focaltech,irq-gpio = <&msm_gpio 13 0x0>;
-			focaltech,display-coords = <0 0 480 854>;
-			focaltech,panel-coords = <0 0 480 950>;
-			focaltech,button-map= <139 102 158>;
-			focaltech,no-force-update;
-			focaltech,i2c-pull-up;
-			focaltech,group-id = <1>;
-			focaltech,hard-reset-delay-ms = <20>;
-			focaltech,soft-reset-delay-ms = <200>;
-			focaltech,num-max-touches = <5>;
-			focaltech,fw-delay-aa-ms = <30>;
-			focaltech,fw-delay-55-ms = <30>;
-			focaltech,fw-upgrade-id1 = <0x79>;
-			focaltech,fw-upgrade-id2 = <0x18>;
-			focaltech,fw-delay-readid-ms = <10>;
-			focaltech,fw-delay-era-flsh-ms = <2000>;
-			focaltech,fw-auto-cal;
-			focaltech,ignore-id-check;
-		};
-*/
+	i2c@78b9000 { /* BLSP1 QUP5 */
+			icn6211@2c {
+						compatible = "qcom,icn6211";
+						reg = <0x2C>;
+						pinctrl-names = "default","sleep";
+						pinctrl-0 = <&icn_default>;
+						pinctrl-1 = <&icn_sleep>;
+						icn,gpio_rstn = <&msm_gpio 21 0x0>;
+						icn,gpio_3V3_en = <&msm_gpio 51 0x0>;
+						icn,gpio_dc_5v_en = <&msm_gpio 50 0x0>;
+						vdd-supply = <&pm8916_l6>;	
+				};
 	};
 	i2c@78b8000 {
 		aw2013@63 {
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dtsi b/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dtsi
index 9499083..439ebd7 100755
--- a/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dtsi
+++ b/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm753-public.dtsi
@@ -18,6 +18,7 @@
 #include "dsi-panel-hx8389b-qhd-video.dtsi"
 #include "dsi-panel-hx8394f-720p-video.dtsi"
 #include "dsi-panel-hx8394f-zzw500hah-720p-video.dtsi"
+#include "dsi-mipi-2-rgb_1280p_video.dtsi"
 
 &soc {
 	gpio-leds {
@@ -119,16 +120,24 @@
 
 &pmx_mdss {
 	qcom,num-grp-pins = <1>;
-	qcom,pins = <&gp 25>;
+	qcom,pins = <&gp 113>;//no use
 };
 
 &mdss_dsi0 {
-	qcom,dsi-pref-prim-pan = <&dsi_otm8019a_fwvga_video>;
+	qcom,dsi-pref-prim-pan = <&dsi_mipi_rgb_1280p_video>;
 	pinctrl-names = "mdss_default", "mdss_sleep";
 	pinctrl-0 = <&mdss_dsi_active>;
 	pinctrl-1 = <&mdss_dsi_suspend>;
 
-	qcom,platform-reset-gpio = <&msm_gpio 25 0>;
+	qcom,platform-reset-gpio = <&msm_gpio 113 0>;//no use 
+};
+
+&dsi_mipi_rgb_1280p_video {
+			qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_pwm";
+			qcom,mdss-dsi-bl-pmic-pwm-frequency = <100>;
+			qcom,mdss-dsi-bl-pmic-bank-select = <0>;
+			qcom,mdss-dsi-pwm-gpio = <&pm8916_mpps 4 0>;
+			//qcom,cont-splash-enabled;
 };
 
 /*add by fangchengbing used for 753 project*/
@@ -167,152 +176,9 @@
 	qcom,cont-splash-enabled;
 };
 
-&tlmm_pinmux {
-	bma2x2_int1_pin {
-		qcom,pins = <&gp 112>;
-		qcom,num-grp-pins = <1>;
-		label = "bma2x2_int1_pin";
-		bma2x2_int1_default: int1_default {
-			  drive-strength = <6>;
-			  bias-pull-up;
-		};
-	};
-	epl2182_int_pin {
-		qcom,pins = <&gp 36>;
-		qcom,pin-func = <0>;
-		qcom,num-grp-pins = <1>;
-		label = "epl2182-irq";
-		epl2182_default: epl2182_default {
-			drive-strength = <6>;
-			bias-pull-up;
-		};
-	};
-	bma2x2_int2_pin {
-		qcom,pins = <&gp 114>;
-		qcom,num-grp-pins = <1>;
-		label = "bma2x2_int2_pin";
-		bma2x2_int2_default: int2_default {
-			  drive-strength = <6>;
-			  bias-pull-up;
-		};
-	};
-};
+/*add by eliot shao 2016.12.14 for icn6211*/
+&i2c_5 {// BLSP1 QUP5
 
-&i2c_0 { /* BLSP1 QUP2 */
-
-/* rm by huangfusheng 2016-12-19 */
-/*
-	bmp280 {
-                compatible = "bmp280";
-                reg = <0x76>;
-        };
-*/
-
-/* rm by huangfusheng 2016-12-19 */
-/*
-	akm@c {
-                compatible = "ak,ak09911";
-                reg = <0x0c>;
-                 pinctrl-names = "default","sleep";
-                pinctrl-0 = <&akm_default>;
-                pinctrl-1 = <&akm_sleep>;
-                vdd-supply = <&pm8916_l17>;
-                vio-supply = <&pm8916_l6>;
-                akm,layout = <0x3>;
-                akm,poll_interval = <200>;
-                akm,gpio_rstn = <&msm_gpio 119 0x0>;
-                akm,auto-report;
-        };
-*/
-
-/* rm by huangfusheng 2016-12-19 */
-/*
-	elan@49 { // Ambient light and proximity sensor
-		compatible = "epl2182";
-		reg = <0x49>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&epl2182_default>;
-		interrupt-parent = <&msm_gpio>;
-		interrupts = <36 0x2002>;
-		vdd-supply = <&pm8916_l17>;
-		vio-supply = <&pm8916_l6>;
-		epl2182,irq-gpio = <&msm_gpio 36 0x2002>;
-		epl2182,prox_th_min = <550>;
-		epl2182,prox_th_max = <850>;
-	};
-*/
-
-/* rm by huangfusheng 2016-12-19 */
-/*
-	avago@39 { // Ambient light and proximity sensor
-		compatible = "avago,apds9930";
-		reg = <0x39>;
-		pinctrl-names = "default","sleep";
-		pinctrl-0 = <&apds99xx_default>;
-		pinctrl-1 = <&apds99xx_sleep>;
-		interrupt-parent = <&msm_gpio>;
-		interrupts = <113 0x2002>;
-		vdd-supply = <&pm8916_l17>;
-		vio-supply = <&pm8916_l6>;
-		avago,irq-gpio = <&msm_gpio 113 0x2002>;
-		avago,ps-threshold = <600>;
-		avago,ps-hysteresis-threshold = <500>;
-		avago,ps-pulse = <8>;
-		avago,ps-pgain = <0>;
-		avago,als-B = <186>;
-		avago,als-C = <75>;
-		avago,als-D = <129>;
-		avago,ga-value = <768>;
-	};
-*/
-
-/* rm by huangfusheng 2016-12-19 */
-/*
-	bosch@18 { // Accelerometer sensor
-		compatible = "bosch,bma2x2";
-		reg = <0x18>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&bma2x2_int1_default &bma2x2_int2_default>;
-		interrupt-parent = <&msm_gpio>;
-		interrupts = <112 0x2002>;
-		vdd-supply = <&pm8916_l17>;
-		vio-supply = <&pm8916_l6>;
-		bosch,init-interval = <200>;
-		bosch,place = <2>;
-		bosch,gpio-int1 = <&msm_gpio 112 0x2002>;
-		bosch,gpio-int2 = <&msm_gpio 114 0x2002>;
-	};
-*/
-
-/* rm by huangfusheng 2016-12-19 */
-/*
-	memsic@30 { // Magnetic field sensor
-		compatible = "memsic,mmc3416x";
-		reg = <0x30>;
-		vdd-supply = <&pm8916_l17>;
-		vio-supply = <&pm8916_l6>;
-		memsic,dir = "obverse-x-axis-forward";
-		memsic,auto-report;
-	};
-*/
-
-/* rm by huangfusheng 2016-12-19 */
-/*
-	mpu6050@68 {
-		compatible = "invn,mpu6050";
-		reg = <0x68>;
-		pinctrl-names = "mpu_default","mpu_sleep";
-		pinctrl-0 = <&mpu6050_default>;
-		pinctrl-1 = <&mpu6050_sleep>;
-		interrupt-parent = <&msm_gpio>;
-		interrupts = <115 0x2>;
-		vdd-supply = <&pm8916_l17>;
-		vlogic-supply = <&pm8916_l16>;
-		vi2c-supply = <&pm8916_l6>;
-		invn,gpio-int = <&msm_gpio 115 0x2>;
-		invn,place = "Portrait Up Back Side";
-	};
-*/
 };
 
 &sdc2_cd_on {
diff --git a/kernel/drivers/input/misc/Makefile b/kernel/drivers/input/misc/Makefile
index 965ee6b..e2078b0 100755
--- a/kernel/drivers/input/misc/Makefile
+++ b/kernel/drivers/input/misc/Makefile
@@ -82,6 +82,7 @@
 #obj-$(CONFIG_SENSORS_BMI160)	+= bmi120_IIO3.4/
 #<--2016-05-9@zhouwei add bmp280 sensor
 obj-y	+= bosch/
+obj-y	+= cxn010x/
 #--!>
 obj-$(CONFIG_SENSORS_BMA2X2)	+= bma2x2.o
 obj-$(CONFIG_SENSORS_LTR553)	+= ltr553.o
diff --git a/kernel/drivers/input/misc/cxn010x/Makefile b/kernel/drivers/input/misc/cxn010x/Makefile
new file mode 100755
index 0000000..ab45773
--- /dev/null
+++ b/kernel/drivers/input/misc/cxn010x/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for cxn010x sony driver.
+#
+
+obj-y  += cxn010x_i2c_interface.o
diff --git a/kernel/drivers/input/misc/cxn010x/cxn010x_i2c_interface.c b/kernel/drivers/input/misc/cxn010x/cxn010x_i2c_interface.c
new file mode 100755
index 0000000..7148e79
--- /dev/null
+++ b/kernel/drivers/input/misc/cxn010x/cxn010x_i2c_interface.c
@@ -0,0 +1,524 @@
+/*
+*author :shaomingliang (Eliot shao)
+*version:1.0
+*data:2016.12.16
+*function description : an i2c interface for cxn0102
+*/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/workqueue.h>
+#include <linux/errno.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+
+
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <linux/notifier.h>
+#include <linux/fb.h>
+
+
+#include "cxn010x_i2c_interface.h"
+
+struct cxn_i2c_interface {
+	unsigned short flags;
+	struct i2c_client *cxn_i2c_client;
+	unsigned int slave_addr ;
+	struct mutex lock;
+	struct mutex i2c_lock;
+	int gpio_rstn ;//for gpio25
+	int gpio_irq ;
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pin_default;
+	struct pinctrl_state	*pin_sleep;
+	spinlock_t irq_lock;
+	struct regulator *vdd;
+
+	unsigned char notify_num ;
+	struct workqueue_struct *cxn_wq;
+	struct work_struct	work;
+
+	unsigned char isActive;
+	struct notifier_block fb_notif;
+
+	//unsigned long isPower;
+};
+
+static struct cxn_i2c_interface *my_cxn_i2c ;
+
+static int icn_reset_chip(void)
+{
+
+	gpio_direction_output(my_cxn_i2c->gpio_rstn, 0);
+	
+	mdelay(50);
+
+	gpio_direction_output(my_cxn_i2c->gpio_rstn, 1);
+
+	return 0;
+}
+#define PINCTRL_STATE_ACTIVE__	 	"pmx_ts_active"
+#define PINCTRL_STATE_SUSPEND__	 	"pmx_ts_suspend"
+
+static int cxn_pinctrl_init(struct cxn_i2c_interface *lt)
+{
+	int retval;
+	struct i2c_client *client = lt->cxn_i2c_client;
+	/* Get pinctrl if target uses pinctrl */
+	lt->pinctrl = devm_pinctrl_get(&client->dev);
+	if (IS_ERR_OR_NULL(lt->pinctrl)) {
+		retval = PTR_ERR(lt->pinctrl);
+		dev_dbg(&client->dev,
+			"Target does not use pinctrl %d\n", retval);
+		goto err_pinctrl_get;
+	}
+	lt->pin_default
+		= pinctrl_lookup_state(lt->pinctrl,
+				PINCTRL_STATE_ACTIVE__);
+	if (IS_ERR_OR_NULL(lt->pin_default)) {
+		retval = PTR_ERR(lt->pin_default);
+		dev_err(&client->dev,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_ACTIVE__, retval);
+		goto err_pinctrl_lookup;
+	}
+	lt->pin_sleep
+		= pinctrl_lookup_state(lt->pinctrl,
+			PINCTRL_STATE_SUSPEND__);
+	if (IS_ERR_OR_NULL(lt->pin_sleep)) {
+		retval = PTR_ERR(lt->pin_sleep);
+		dev_err(&client->dev,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_SUSPEND__, retval);
+		goto err_pinctrl_lookup;
+	}
+
+	return 0;
+
+err_pinctrl_lookup:
+	devm_pinctrl_put(lt->pinctrl);
+err_pinctrl_get:
+	lt->pinctrl = NULL;
+	return retval;
+}
+
+void cxn_irq_disable(struct cxn_i2c_interface *cxn)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&cxn->irq_lock, irqflags);
+	disable_irq_nosync(cxn->cxn_i2c_client->irq);
+	spin_unlock_irqrestore(&cxn->irq_lock, irqflags);
+}
+
+void cxn_irq_enable(struct cxn_i2c_interface *cxn)
+{
+	unsigned long irqflags = 0;
+
+	spin_lock_irqsave(&cxn->irq_lock, irqflags);
+	enable_irq(cxn->cxn_i2c_client->irq);
+	spin_unlock_irqrestore(&cxn->irq_lock, irqflags);
+}
+
+static irqreturn_t cxn_irq_handler(int irq, void *dev_id)
+{
+	struct cxn_i2c_interface *cxn = dev_id;
+	
+
+	cxn_irq_disable(cxn);
+	//printk(KERN_ERR "eliot :cxn_irq_handler...");
+	cxn->notify_num ++ ;
+	queue_work(cxn->cxn_wq, &cxn->work);
+
+	return IRQ_HANDLED;
+}
+
+static int cxn_request_irq(struct cxn_i2c_interface *ts)
+{
+	int ret = -1;
+
+	ret = request_irq(ts->cxn_i2c_client->irq, cxn_irq_handler,
+			  IRQ_TYPE_EDGE_RISING,
+			  ts->cxn_i2c_client->name, ts);
+	if (ret) {
+		printk(KERN_ERR "Request IRQ failed!ERRNO:%d.", ret);
+		return ret;
+	} else {
+		cxn_irq_disable(ts);
+		return 0;
+	}
+}
+static int cxn_open(void)
+{
+	char w_value[5]={0};
+	int ret ;
+	//printk(KERN_ERR "eliot cxn_open\n");
+	w_value[0] = 1 ;w_value[1] = 0 ;//open cmd
+	mutex_lock(&my_cxn_i2c->lock);
+	ret = i2c_master_send(my_cxn_i2c->cxn_i2c_client,w_value,2);
+	mutex_unlock(&my_cxn_i2c->lock);
+	return ret ;
+	
+}
+
+static void cxn_stop(void)
+{
+	char w_value[5]={0};
+	int ret ;
+	//printk(KERN_ERR "eliot cxn_stop\n");
+	w_value[0] = 2 ;w_value[1] = 0 ;//stop cmd
+	mutex_lock(&my_cxn_i2c->lock);
+	ret = i2c_master_send(my_cxn_i2c->cxn_i2c_client,w_value,2);
+	mutex_unlock(&my_cxn_i2c->lock);
+
+	//return ret ;
+	
+}
+
+#if 0 
+static void cxn_shutdown(void)
+{
+	char w_value[5]={0};
+	int ret ;
+	w_value[0] = 0x0b ;w_value[1] = 1 ;w_value[2] = 0 ;//shutdown cmd
+	mutex_lock(&my_cxn_i2c->lock);
+	ret = i2c_master_send(my_cxn_i2c->cxn_i2c_client,w_value,3);
+	mutex_unlock(&my_cxn_i2c->lock);
+}
+static void cxn_reboot(void)
+{
+	char w_value[5]={0};
+	int ret ;
+	w_value[0] = 0x0b ;w_value[1] = 1 ;w_value[2] = 1 ;//shutdown cmd
+	mutex_lock(&my_cxn_i2c->lock);
+	ret = i2c_master_send(my_cxn_i2c->cxn_i2c_client,w_value,3);
+	mutex_unlock(&my_cxn_i2c->lock);
+}
+#endif
+static int cxn_i2c_resume(struct device *tdev) {
+	//printk(KERN_ERR "eliot cxn_i2c_resume my_cxn_i2c->isActive = %d\n",my_cxn_i2c->isActive);
+	if(my_cxn_i2c->isActive==0){
+		icn_reset_chip();
+	}
+    return 0;
+}
+
+static int cxn_i2c_remove(struct i2c_client *client) {
+	
+    return 0;
+}
+
+static int cxn_i2c_suspend(struct device *tdev) {
+	//printk(KERN_ERR "eliot cxn_i2c_suspend my_cxn_i2c->isActive = %d\n",my_cxn_i2c->isActive);
+	if(my_cxn_i2c->isActive==1){
+		cxn_stop();
+		gpio_direction_output(my_cxn_i2c->gpio_rstn, 0);
+		my_cxn_i2c->isActive = 0;
+	}
+    return 0;
+}
+
+static ssize_t cxn_ctl_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int ret ;
+	struct cxn_i2c_interface *cxn = dev_get_drvdata(dev);
+
+	sprintf(buf, "%d\n",cxn->isActive);  
+  
+	ret = strlen(buf) + 1;  
+	return ret; 
+}
+
+static ssize_t cxn_ctl_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	//int ret ;
+	struct cxn_i2c_interface *cxn = dev_get_drvdata(dev);
+	
+	unsigned long on_off = simple_strtoul(buf, NULL, 10);  
+
+	if(on_off == 1 && cxn->isActive == 0)
+	{
+		cxn_i2c_resume(&cxn->cxn_i2c_client->dev);
+	}
+	else if(on_off == 0 && cxn->isActive == 1)
+	{
+		cxn_i2c_suspend(&cxn->cxn_i2c_client->dev);
+		
+	}else
+	printk(KERN_ERR "eliot :no need do this \n");
+
+	return size;
+}
+
+static DEVICE_ATTR(cxn_ctl, 0666,
+			cxn_ctl_show,
+			cxn_ctl_store);
+/*
+static DEVICE_ATTR(fw_upgrade, (S_IRUGO | S_IWUSR | S_IWGRP),
+			gtp_fw_upgrade_show,
+			gtp_fw_upgrade_store);
+static DEVICE_ATTR(force_fw_upgrade, (S_IRUGO | S_IWUSR | S_IWGRP),
+			gtp_fw_upgrade_show,
+			gtp_force_fw_upgrade_store);
+*/
+static struct attribute *cxn_attrs[] = {
+	&dev_attr_cxn_ctl.attr,
+	//&dev_attr_fw_upgrade.attr,
+	//&dev_attr_force_fw_upgrade.attr,
+	NULL
+};
+static const struct attribute_group cxn_attr_grp = {
+	.attrs = cxn_attrs,
+};
+
+static void cxn_work_func(struct work_struct *work)
+{
+	
+	int ret ;
+	char r_value[5]={0};
+
+	struct cxn_i2c_interface *cxn = container_of(work, struct cxn_i2c_interface, work);
+	
+	mutex_lock(&cxn->i2c_lock);
+	//printk(KERN_ERR "eliot :cxn_irq_handler..start.notify_num= %d\n",cxn->notify_num);
+	/*read notify*/
+	/*st + slave addr + r + [ack] + [data1] + ack +[data2] +ack +[data3]+ nack +stop */
+	
+	ret = i2c_master_recv(cxn->cxn_i2c_client,r_value,3);
+	//printk(KERN_ERR "eliot: ret = %d,value[0]=%d,value[1]=%d,value[2]=%d\n",ret,r_value[0],r_value[1],r_value[2]);
+	if(r_value[0]==0 && r_value[1]==1 && r_value[2]==0)
+	{
+		cxn_open();
+		cxn->isActive = 1 ;//open nomal
+	}
+
+	//printk(KERN_ERR "eliot :cxn_irq_handler.ok..\n");
+	mutex_unlock(&cxn->i2c_lock);
+	cxn_irq_enable(cxn);
+	
+}
+#if defined(CONFIG_FB)
+static int fb_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct cxn_i2c_interface *cxn =
+		container_of(self, struct cxn_i2c_interface, fb_notif);
+
+	if (evdata && evdata->data && event == FB_EVENT_BLANK &&
+			cxn && cxn->cxn_i2c_client) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK)
+			cxn_i2c_resume(&cxn->cxn_i2c_client->dev);
+		else if (*blank == FB_BLANK_POWERDOWN)
+			cxn_i2c_suspend(&cxn->cxn_i2c_client->dev);
+	}
+
+	return 0;
+}
+#endif
+
+
+#define I2C_VTG_MIN_UV__	1800000
+#define I2C_VTG_MAX_UV__	1800000
+
+static int cxn_i2c_probe(struct i2c_client *client,
+        const struct i2c_device_id *id) 
+{
+	int err = 0 ;
+	printk(KERN_ERR "eliot :cxn_i2c_probe start.....");
+	
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev,
+				"%s: check_functionality failed.", __func__);
+		err = -ENODEV;
+		goto exit0;
+	}
+
+	/* Allocate memory for driver data */
+	my_cxn_i2c = kzalloc(sizeof(struct cxn_i2c_interface), GFP_KERNEL);
+	
+	if (!my_cxn_i2c) {
+		dev_err(&client->dev,
+				"%s: memory allocation failed.", __func__);
+		err = -ENOMEM;
+		goto exit1;
+	}
+	memset(my_cxn_i2c, 0, sizeof(*my_cxn_i2c));
+	
+	spin_lock_init(&my_cxn_i2c->irq_lock);
+	mutex_init(&my_cxn_i2c->lock);
+	mutex_init(&my_cxn_i2c->i2c_lock);
+
+	#if defined(CONFIG_FB)
+	my_cxn_i2c->fb_notif.notifier_call = fb_notifier_callback;
+	err = fb_register_client(&my_cxn_i2c->fb_notif);
+	if (err)
+		printk(KERN_ERR "eliot :fb_notifier_callback err.....");
+	#endif
+	
+	my_cxn_i2c->notify_num = 0 ;
+	my_cxn_i2c->isActive = 0 ;
+	
+	my_cxn_i2c->cxn_wq = create_singlethread_workqueue("cxn_wq");
+	INIT_WORK(&my_cxn_i2c->work, cxn_work_func);
+	
+	if (!my_cxn_i2c->cxn_wq) {
+		printk(KERN_ERR "eliot :Creat workqueue failed.");
+		return -ENOMEM;
+	}
+	if (client->dev.of_node) {
+	my_cxn_i2c->gpio_rstn= of_get_named_gpio_flags(client->dev.of_node,
+			"cxn-reset-gpios", 0, NULL);
+	my_cxn_i2c->gpio_irq= of_get_named_gpio_flags(client->dev.of_node,
+			"cxn-interrupt-gpios", 0, NULL);
+	}
+	else
+	{
+		printk(KERN_ERR "eliot:client->dev.of_node not exit!\n");
+	}
+
+	/***** I2C initialization *****/
+	my_cxn_i2c->cxn_i2c_client = client;
+	
+	/* set client data */
+	i2c_set_clientdata(client, my_cxn_i2c);
+
+	/*open l6 1.8 V*/
+	
+	my_cxn_i2c->vdd = regulator_get(&client->dev, "vdd");
+	
+	if (IS_ERR(my_cxn_i2c->vdd)) {
+		err = PTR_ERR(my_cxn_i2c->vdd);
+		printk(KERN_ERR "eliot:vdd get erro err = %d\n",err);
+		goto exit1;
+	}else
+	{
+		regulator_set_voltage(my_cxn_i2c->vdd, I2C_VTG_MIN_UV__,
+					   I2C_VTG_MAX_UV__);
+		err = regulator_enable(my_cxn_i2c->vdd);
+		if (err) {
+			dev_err(&client->dev,
+				"Regulator vdd enable failed ret=%d\n", err);
+			goto exit2;
+		}
+	}
+	
+	/* initialize pinctrl */
+	if (!cxn_pinctrl_init(my_cxn_i2c)) {
+		err = pinctrl_select_state(my_cxn_i2c->pinctrl, my_cxn_i2c->pin_default);
+		if (err) {
+			dev_err(&client->dev, "Can't select pinctrl state\n");
+			goto exit2;
+		}
+	}
+	
+	mutex_lock(&my_cxn_i2c->lock);
+
+	/* Pull up the reset pin */
+	/* request  GPIO  */
+	err = gpio_request(my_cxn_i2c->gpio_rstn, "cxn-reset-gpios");
+	if (err < 0) {
+		printk(KERN_ERR "Failed to request GPIO:%d, ERRNO:%d",
+			  my_cxn_i2c->gpio_rstn, err);
+		err = -ENODEV;
+		mutex_unlock(&my_cxn_i2c->lock);
+		goto exit3; 
+	}
+	err = gpio_request(my_cxn_i2c->gpio_irq, "cxn-interrupt-gpios");
+	if (err < 0) {
+		printk(KERN_ERR "Failed to request GPIO:%d, ERRNO:%d",
+			  my_cxn_i2c->gpio_irq, err);
+		gpio_free(my_cxn_i2c->gpio_rstn);
+		err = -ENODEV;
+		mutex_unlock(&my_cxn_i2c->lock);
+		goto exit3; 
+	}
+
+	//config irq pin
+	err = gpio_direction_input(my_cxn_i2c->gpio_irq);
+	if (err < 0)
+		gpio_free(my_cxn_i2c->gpio_irq);
+	my_cxn_i2c->cxn_i2c_client->irq = gpio_to_irq(my_cxn_i2c->gpio_irq);
+
+	//allocat irq gpio36
+	err = cxn_request_irq(my_cxn_i2c);
+	if (err < 0){
+		printk(KERN_ERR "cxn_request_irq fail !!\n");
+		goto exit4 ;
+	}
+	else
+		printk(KERN_ERR "cxn_request_irq works !!!\n");
+	
+	err = sysfs_create_group(&client->dev.kobj, &cxn_attr_grp);
+	if (err < 0) {
+		dev_err(&client->dev, "eliot :sys file creation failed.\n");
+		goto exit5;
+	}
+
+	//reset enable
+	gpio_direction_output(my_cxn_i2c->gpio_rstn, 0);
+	mdelay(50);
+	gpio_direction_output(my_cxn_i2c->gpio_rstn, 1);
+	cxn_irq_enable(my_cxn_i2c);
+
+	mutex_unlock(&my_cxn_i2c->lock);
+	printk(KERN_ERR "eliot :cxn_i2c_probe end ....\n");
+	return 0;
+exit5:
+	free_irq(client->irq, my_cxn_i2c);
+exit4:
+	gpio_free(my_cxn_i2c->gpio_rstn);
+	gpio_free(my_cxn_i2c->gpio_irq);
+exit3:
+	mutex_destroy(&my_cxn_i2c->lock);
+	mutex_destroy(&my_cxn_i2c->i2c_lock);
+exit2:
+	regulator_disable(my_cxn_i2c->vdd);
+exit1:
+	kfree(my_cxn_i2c);
+exit0:
+	return err ;
+}
+
+static const struct of_device_id cxn010x_i2c_of_match[] = {
+    { .compatible = "qcom,cxn0102",},
+    {},
+};
+
+static const struct i2c_device_id cxn_i2c_id[] = {
+    {"qcom,cxn0102", 0},
+    {},
+};
+
+
+static struct i2c_driver cxn010x_i2c_driver = {
+    .driver = {
+        .name = "qcom,cxn0102",
+        .owner    = THIS_MODULE,
+        .of_match_table = cxn010x_i2c_of_match,
+        
+    },
+    .probe    = cxn_i2c_probe,
+    .remove   = cxn_i2c_remove,
+    .id_table = cxn_i2c_id,
+};
+
+module_i2c_driver(cxn010x_i2c_driver);
+
+MODULE_LICENSE("GPL");
+
diff --git a/kernel/drivers/input/misc/cxn010x/cxn010x_i2c_interface.h b/kernel/drivers/input/misc/cxn010x/cxn010x_i2c_interface.h
new file mode 100755
index 0000000..139597f
--- /dev/null
+++ b/kernel/drivers/input/misc/cxn010x/cxn010x_i2c_interface.h
@@ -0,0 +1,2 @@
+
+
diff --git a/kernel/drivers/video/msm/mdss/Makefile b/kernel/drivers/video/msm/mdss/Makefile
index a5f4473..191cf7e 100644
--- a/kernel/drivers/video/msm/mdss/Makefile
+++ b/kernel/drivers/video/msm/mdss/Makefile
@@ -13,6 +13,7 @@
 mdss-mdp-objs += mdss_mdp_overlay.o
 mdss-mdp-objs += mdss_mdp_splash_logo.o
 mdss-mdp-objs += mdss_mdp_wb.o
+mdss-mdp-objs += mdss_i2c_interface.o
 obj-$(CONFIG_FB_MSM_MDSS) += mdss-mdp.o
 obj-$(CONFIG_FB_MSM_MDSS) += mdss_mdp_debug.o
 
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi.h b/kernel/drivers/video/msm/mdss/mdss_dsi.h
index de1b3c5..45e5e94 100644
--- a/kernel/drivers/video/msm/mdss/mdss_dsi.h
+++ b/kernel/drivers/video/msm/mdss/mdss_dsi.h
@@ -281,6 +281,11 @@
 	DSI_CTRL_1,
 	DSI_CTRL_MAX,
 };
+/*enum that define type of access register default is dsi*/
+enum i2c_cmd_access_type {
+    CMD_ACCESS_DSI,
+    CMD_ACCESS_I2C,
+};
 
 #define DSI_CTRL_LEFT		DSI_CTRL_0
 #define DSI_CTRL_RIGHT		DSI_CTRL_1
@@ -354,6 +359,9 @@
 	bool dsi_irq_line;
 	atomic_t te_irq_ready;
 
+//add by eliot shao 2016.9.9
+	int cmd_access ;
+
 	bool cmd_clk_ln_recovery_en;
 	bool cmd_sync_wait_broadcast;
 	bool cmd_sync_wait_trigger;
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi_host.c b/kernel/drivers/video/msm/mdss/mdss_dsi_host.c
index e8e705b..0e9a44c 100644
--- a/kernel/drivers/video/msm/mdss/mdss_dsi_host.c
+++ b/kernel/drivers/video/msm/mdss/mdss_dsi_host.c
@@ -27,6 +27,8 @@
 #include "mdss_dsi.h"
 #include "mdss_panel.h"
 #include "mdss_debug.h"
+#include "mdss_i2c_interface.h"
+
 
 #define VSYNC_PERIOD 17
 
@@ -110,8 +112,12 @@
 	mdss_dsi_buf_alloc(ctrl_dev, &ctrl->tx_buf, SZ_4K);
 	mdss_dsi_buf_alloc(ctrl_dev, &ctrl->rx_buf, SZ_4K);
 	mdss_dsi_buf_alloc(ctrl_dev, &ctrl->status_buf, SZ_4K);
-	ctrl->cmdlist_commit = mdss_dsi_cmdlist_commit;
-
+	//ctrl->cmdlist_commit = mdss_dsi_cmdlist_commit;
+		/*diff two register access type add by eliot shao 2016.9.9*/
+	if (ctrl->cmd_access == CMD_ACCESS_DSI)
+		ctrl->cmdlist_commit = mdss_dsi_cmdlist_commit;
+	else if (ctrl->cmd_access == CMD_ACCESS_I2C)
+		ctrl->cmdlist_commit = mdss_mipi_i2c_init;
 
 	if (dsi_event.inited == 0) {
 		kthread_run(dsi_event_thread, (void *)&dsi_event,
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c b/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c
index fb83c75..4a6086a 100644
--- a/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c
+++ b/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c
@@ -23,6 +23,7 @@
 #include <linux/err.h>
 
 #include "mdss_dsi.h"
+#include "mdss_i2c_interface.h"
 
 #define DT_CMD_HDR 6
 
@@ -617,9 +618,15 @@
 			goto end;
 	}
 
-	if (ctrl->on_cmds.cmd_cnt)
-		mdss_dsi_panel_cmds_send(ctrl, &ctrl->on_cmds);
-
+//	if (ctrl->on_cmds.cmd_cnt)
+//		mdss_dsi_panel_cmds_send(ctrl, &ctrl->on_cmds);
+	if (ctrl->cmd_access == CMD_ACCESS_DSI) {
+	    if (ctrl->on_cmds.cmd_cnt)
+			  mdss_dsi_panel_cmds_send(ctrl, &ctrl->on_cmds);
+	} else if (ctrl->cmd_access == CMD_ACCESS_I2C) {
+    	//add by eliot shao 
+	 	mdss_mipi_i2c_init(ctrl,0);
+ 	 }	
 end:
 	pinfo->blank_state = MDSS_PANEL_BLANK_UNBLANK;
 	pr_debug("%s:-\n", __func__);
@@ -1347,6 +1354,7 @@
 	if (data && !strncmp(data, "dsi_cmd_mode", 12))
 		pinfo->mipi.mode = DSI_CMD_MODE;
 	tmp = 0;
+	//pinfo->mipi.force_clk_lane_hs = 1;
 	data = of_get_property(np, "qcom,mdss-dsi-pixel-packing", NULL);
 	if (data && !strcmp(data, "loose"))
 		pinfo->mipi.pixel_packing = 1;
@@ -1606,6 +1614,17 @@
 
 	mdss_dsi_parse_reset_seq(np, pinfo->rst_seq, &(pinfo->rst_seq_len),
 		"qcom,mdss-dsi-reset-sequence");
+	//add by eliot shao 2016.9.9 start 
+	rc = of_property_read_string(np,
+          "qcom,mdss-command-access", &data);
+  	if (!rc) {
+	    if (!strcmp(data, "i2c")) {
+	      ctrl_pdata->cmd_access = CMD_ACCESS_I2C;
+
+	    } else   /*normal flow*/
+	       ctrl_pdata->cmd_access = CMD_ACCESS_DSI;
+  	}
+	//add by eliot shao 2016.9.9 end 	
 
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->on_cmds,
 		"qcom,mdss-dsi-on-command", "qcom,mdss-dsi-on-command-state");
diff --git a/kernel/drivers/video/msm/mdss/mdss_i2c_interface.c b/kernel/drivers/video/msm/mdss/mdss_i2c_interface.c
new file mode 100755
index 0000000..96e885f
--- /dev/null
+++ b/kernel/drivers/video/msm/mdss/mdss_i2c_interface.c
@@ -0,0 +1,391 @@
+/*
+*author :shaomingliang (Eliot shao)
+*version:1.0
+*data:2016.9.9
+*function description : an i2c interface for mipi bridge or others i2c slave
+*/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/workqueue.h>
+#include <linux/errno.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+
+#include "mdss_i2c_interface.h"
+#include "mdss_dsi.h"
+
+struct mdss_i2c_interface {
+	unsigned short flags;
+	struct i2c_client *mdss_mipi_i2c_client;
+	unsigned int slave_addr ;
+	struct mutex lock;
+	struct mutex i2c_lock;
+	int gpio_rstn ;//for icn6211
+	int gpio_3V3_en;
+	int gpio_dc_5v_en;
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pin_default;
+	struct pinctrl_state	*pin_sleep;
+	
+	struct regulator *vdd;
+};
+
+static struct mdss_i2c_interface *my_mipi_i2c ;
+
+
+/*if I2C_TEST_OK == 1 stand for lt8912's i2c no ack , and the 
+resource of my_mipi_i2c has been remove .must be stop here !
+or will happen null pointer error !
+*/
+
+static int I2C_TEST_OK  = 0 ; //default
+	
+int HDMI_WriteI2C_Byte(int reg, int val)
+{
+	int rc = 0;
+	rc = i2c_smbus_write_byte_data(my_mipi_i2c->mdss_mipi_i2c_client,reg,val);
+	if (rc < 0) {
+		printk("eliot :HDMI_WriteI2C_Byte fail \n");
+        return rc;
+		}
+	return rc ;
+}
+int HDMI_ReadI2C_Byte(int reg)
+{
+	int val = 0;
+	val = i2c_smbus_read_byte_data(my_mipi_i2c->mdss_mipi_i2c_client, reg);
+    if (val < 0) {
+        dev_err(&my_mipi_i2c->mdss_mipi_i2c_client->dev, "i2c read fail: can't read from %02x: %d\n", 0, val);
+        return val;
+    } 
+	return val ;
+}
+
+static int Reset_chip(void)
+{
+
+	gpio_direction_output(my_mipi_i2c->gpio_rstn, 0);
+	mdelay(50);
+
+	gpio_direction_output(my_mipi_i2c->gpio_rstn, 1);
+
+	return 0;
+}
+/* no external clk 
+0x20 , 0x00
+0x21 , 0xD0
+0x22 , 0x25
+0x23 , 0x6E
+0x24 , 0x28
+0x25 , 0xDC
+0x26 , 0x00
+0x27 , 0x05
+0x28 , 0x05
+0x29 , 0x14
+0x34 , 0x80
+0x36 , 0x6E
+0xB5 , 0xA0
+0x5C , 0xFF
+0x2A , 0x07
+0x56 , 0x92
+0x6B , 0x52
+0x69 , 0x2C
+0x10 , 0x40
+0x11 , 0x88
+0xB6 , 0x20
+0x51 , 0x20
+0x09 , 0x10
+*/
+/*own external clk
+0x20 = 0x00
+0x21 = 0xD0
+0x22 = 0x25
+0x23 = 0x6E
+0x24 = 0x28
+0x25 = 0xDC
+0x26 = 0x00
+0x27 = 0x05
+0x28 = 0x05
+0x29 = 0x14
+0x34 = 0x80
+0x36 = 0x6E
+0xB5 = 0xA0
+0x5C = 0xFF
+0x2A = 0x07
+0x56 = 0x90
+0x6B = 0x51
+0x69 = 0x2F
+0x10 = 0x40
+0x11 = 0x88
+0xB6 = 0x20
+0x51 = 0x20
+0x09 = 0x10
+*/
+/*This function para Get from FAE*/
+int mdss_mipi_i2c_init(struct mdss_dsi_ctrl_pdata *ctrl, int from_mdp)
+{
+	//printk(KERN_ERR "eliot :mdss_mipi_i2c_init start \n");
+	//Reset_chip();
+	/*if I2C_TEST_OK == 1 stand for lt8912's i2c no ack , and the 
+	resource of my_mipi_i2c has been remove .must be stop here !
+	*/
+	if(I2C_TEST_OK  == 0)
+	{
+		printk(KERN_ERR "eliot :i2c test erro or mdss i2c interface donot probe \n");
+		return 0;
+	}
+	// ÍùLT8912¼Ä´æÆ÷Ð´Öµ£º
+	//******************************************//
+		mutex_lock(&my_mipi_i2c->i2c_lock);
+
+		HDMI_WriteI2C_Byte(0x20 , 0x00);// Register address : 0x08;	Value : 0xff
+		HDMI_WriteI2C_Byte(0x21 , 0xD0);
+		HDMI_WriteI2C_Byte(0x22 , 0x25);
+		HDMI_WriteI2C_Byte(0x23 , 0x6E);
+		HDMI_WriteI2C_Byte(0x24 , 0x28);
+		HDMI_WriteI2C_Byte(0x25 , 0xDC);
+		HDMI_WriteI2C_Byte(0x26 , 0x00);
+		HDMI_WriteI2C_Byte(0x27 , 0x05);
+		HDMI_WriteI2C_Byte(0x28 , 0x05);
+		HDMI_WriteI2C_Byte(0x29 , 0x14);
+		HDMI_WriteI2C_Byte(0x34 , 0x80);
+		HDMI_WriteI2C_Byte(0x36 , 0x6E);
+		HDMI_WriteI2C_Byte(0xB5 , 0xA0);
+		HDMI_WriteI2C_Byte(0x5C , 0xFF);
+		HDMI_WriteI2C_Byte(0x2A , 0x07);
+		HDMI_WriteI2C_Byte(0x56 , 0x92);
+		HDMI_WriteI2C_Byte(0x6B , 0x52);
+		HDMI_WriteI2C_Byte(0x69 , 0x2C);
+		HDMI_WriteI2C_Byte(0x10 , 0x40);
+		HDMI_WriteI2C_Byte(0x11 , 0x88);
+		HDMI_WriteI2C_Byte(0xB6 , 0x20);
+		HDMI_WriteI2C_Byte(0x51 , 0x20);
+		HDMI_WriteI2C_Byte(0x09 , 0x10);
+		
+		mutex_unlock(&my_mipi_i2c->i2c_lock);
+
+		//printk(KERN_ERR "eliot :mdss_mipi_i2c_init end \n");
+		return 0 ;
+	
+}
+
+EXPORT_SYMBOL_GPL(mdss_mipi_i2c_init);
+
+static int lt_pinctrl_init(struct mdss_i2c_interface *lt)
+{
+	struct i2c_client *client = lt->mdss_mipi_i2c_client;
+
+	lt->pinctrl = devm_pinctrl_get(&client->dev);
+	if (IS_ERR_OR_NULL(lt->pinctrl)) {
+		dev_err(&client->dev, "Failed to get pinctrl\n");
+		return PTR_ERR(lt->pinctrl);
+	}
+
+	lt->pin_default = pinctrl_lookup_state(lt->pinctrl, "default");
+	if (IS_ERR_OR_NULL(lt->pin_default)) {
+		dev_err(&client->dev, "Failed to look up default state\n");
+		return PTR_ERR(lt->pin_default);
+	}
+
+	lt->pin_sleep = pinctrl_lookup_state(lt->pinctrl, "sleep");
+	if (IS_ERR_OR_NULL(lt->pin_sleep)) {
+		dev_err(&client->dev, "Failed to look up sleep state\n");
+		return PTR_ERR(lt->pin_sleep);
+	}
+
+	return 0;
+}
+
+/*
+	1.get reset pin and request gpio ;
+	2.get i2c client ,check i2c function and test read i2c slave ;
+	3.send lt8912 i2c configuration table
+*/
+#define I2C_VTG_MIN_UV	1800000
+#define I2C_VTG_MAX_UV	1800000
+
+static int mipi_i2c_probe(struct i2c_client *client,
+        const struct i2c_device_id *id) 
+{
+  int err;
+	struct mdss_dsi_ctrl_pdata *ctrl=NULL;
+	int from_mdp=0 ;
+
+	printk(KERN_ERR "eliot :mipi_i2c_probe start.....");
+	
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev,
+				"%s: check_functionality failed.", __func__);
+		err = -ENODEV;
+		goto exit0;
+	}
+
+	/* Allocate memory for driver data */
+	my_mipi_i2c = kzalloc(sizeof(struct mdss_i2c_interface), GFP_KERNEL);
+	if (!my_mipi_i2c) {
+		dev_err(&client->dev,
+				"%s: memory allocation failed.", __func__);
+		err = -ENOMEM;
+		goto exit1;
+	}
+	
+	mutex_init(&my_mipi_i2c->lock);
+	mutex_init(&my_mipi_i2c->i2c_lock);
+
+	if (client->dev.of_node) {
+	my_mipi_i2c->gpio_rstn = of_get_named_gpio_flags(client->dev.of_node,
+			"icn,gpio_rstn", 0, NULL);
+	my_mipi_i2c->gpio_3V3_en= of_get_named_gpio_flags(client->dev.of_node,
+			"icn,gpio_3V3_en", 0, NULL);
+	my_mipi_i2c->gpio_dc_5v_en= of_get_named_gpio_flags(client->dev.of_node,
+			"icn,gpio_dc_5v_en", 0, NULL);
+	//printk("eliot:my_mipi_i2c->gpio_rstn=%d\n",my_mipi_i2c->gpio_rstn);
+	}
+	else
+	{
+		printk(KERN_ERR "eliot:client->dev.of_node not exit!\n");
+	}
+
+	/***** I2C initialization *****/
+	my_mipi_i2c->mdss_mipi_i2c_client = client;
+	
+	/* set client data */
+	i2c_set_clientdata(client, my_mipi_i2c);
+
+		/*donot free power , camera using else*/
+	err = gpio_request(my_mipi_i2c->gpio_3V3_en, "gpio_3V3_en");
+	err = gpio_request(my_mipi_i2c->gpio_dc_5v_en, "gpio_dc_5v_en");
+	gpio_direction_output(my_mipi_i2c->gpio_3V3_en, 1);
+	gpio_direction_output(my_mipi_i2c->gpio_dc_5v_en, 1);
+	
+	/*open l6 1.8 V*/
+	
+	my_mipi_i2c->vdd = regulator_get(&client->dev, "vdd");
+	if (IS_ERR(my_mipi_i2c->vdd)) {
+		err = PTR_ERR(my_mipi_i2c->vdd);
+		printk(KERN_ERR "eliot:vdd get erro err = %d\n",err);
+		goto exit1;
+	}else
+	{
+		regulator_set_voltage(my_mipi_i2c->vdd, I2C_VTG_MIN_UV,
+					   I2C_VTG_MAX_UV);
+		err = regulator_enable(my_mipi_i2c->vdd);
+		if (err) {
+			dev_err(&client->dev,
+				"Regulator vdd enable failed ret=%d\n", err);
+			goto exit2;
+		}
+	}
+
+	
+	/* initialize pinctrl */
+	if (!lt_pinctrl_init(my_mipi_i2c)) {
+		err = pinctrl_select_state(my_mipi_i2c->pinctrl, my_mipi_i2c->pin_default);
+		if (err) {
+			dev_err(&client->dev, "Can't select pinctrl state\n");
+			goto exit2;
+		}
+	}
+	mutex_lock(&my_mipi_i2c->lock);
+
+	/* Pull up the reset pin */
+	/* request  GPIO  */
+	err = gpio_request(my_mipi_i2c->gpio_rstn, "icn6211_rsrn");
+	if (err < 0) {
+		mutex_unlock(&my_mipi_i2c->lock);
+		printk(KERN_ERR "Failed to request GPIO:%d, ERRNO:%d",
+			  my_mipi_i2c->gpio_rstn, err);
+		err = -ENODEV;
+		goto exit2;
+	}else{
+			gpio_direction_output(my_mipi_i2c->gpio_rstn, 0);
+			mdelay(50);
+			gpio_direction_output(my_mipi_i2c->gpio_rstn, 1);
+		}
+		//printk(KERN_ERR "eliot :icn6211 addr = 0x%x ....\n",my_mipi_i2c->mdss_mipi_i2c_client->addr);
+    err = i2c_smbus_read_byte_data(client, 0x0);
+    if ((err < 0)&&(err != 0xc1)) {
+			//I2C_TEST_OK = 0 ;
+			mutex_unlock(&my_mipi_i2c->lock);
+			gpio_direction_output(my_mipi_i2c->gpio_rstn, 0);
+			dev_err(&client->dev, "i2c read fail: can't read from %02x: %d\n", client->addr, err);
+	        goto exit3;
+    } 
+	I2C_TEST_OK = 1 ;
+  //printk(KERN_ERR "eliot :icn6211 reg 0 val = 0x%x ....\n",err);
+	mdss_mipi_i2c_init(ctrl,from_mdp);
+	mutex_unlock(&my_mipi_i2c->lock);
+	printk(KERN_ERR "eliot :mipi_i2c_probe end ....\n");
+	return 0;
+exit3:
+	gpio_free(my_mipi_i2c->gpio_rstn);
+
+exit2:
+	regulator_disable(my_mipi_i2c->vdd);
+exit1:
+	mutex_destroy(&my_mipi_i2c->lock);
+	mutex_destroy(&my_mipi_i2c->i2c_lock);
+	kfree(my_mipi_i2c);
+exit0:
+	return err;
+
+}
+
+static const struct of_device_id mipi_i2c_of_match[] = {
+    { .compatible = "qcom,icn6211",},
+    {},
+};
+
+static const struct i2c_device_id mipi_i2c_id[] = {
+    {"qcom,icn6211", 0},
+    {},
+};
+static int mipi_i2c_resume(struct device *tdev) {
+	Reset_chip();
+    return 0;
+}
+
+static int mipi_i2c_remove(struct i2c_client *client) {
+	
+    return 0;
+}
+
+static int mipi_i2c_suspend(struct device *tdev) {
+	gpio_direction_output(my_mipi_i2c->gpio_rstn, 0);
+    return 0;
+}
+
+static const struct dev_pm_ops mipi_i2c_pm_ops =
+{ 
+    .suspend = mipi_i2c_suspend,
+    .resume = mipi_i2c_resume, 
+};
+
+
+static struct i2c_driver mipi_i2c_driver = {
+    .driver = {
+        .name = "qcom,icn6211",
+        .owner    = THIS_MODULE,
+        .of_match_table = mipi_i2c_of_match,
+        .pm = &mipi_i2c_pm_ops,
+    },
+    .probe    = mipi_i2c_probe,
+    .remove   = mipi_i2c_remove,
+    .id_table = mipi_i2c_id,
+};
+
+module_i2c_driver(mipi_i2c_driver);
+
+MODULE_LICENSE("GPL");
+
diff --git a/kernel/drivers/video/msm/mdss/mdss_i2c_interface.h b/kernel/drivers/video/msm/mdss/mdss_i2c_interface.h
new file mode 100755
index 0000000..6a618bd
--- /dev/null
+++ b/kernel/drivers/video/msm/mdss/mdss_i2c_interface.h
@@ -0,0 +1,6 @@
+#include "mdss_dsi.h"
+
+//int mdss_mipi_i2c_init(void);
+int mdss_mipi_i2c_init(struct mdss_dsi_ctrl_pdata *ctrl, int from_mdp);
+
+
