From 1873607afea889373c03654179940c46b5945557 Mon Sep 17 00:00:00 2001
From: shaomingliang <shaomingliang@meigsmart.com>
Date: Wed, 14 Sep 2016 10:23:42 +0800
Subject: [PATCH] [BugID]4162  [SLM755][Description] Add mipi-2-hdmi support [Solution]add a i2c driver & 1280x720 panel as hdmi.

Change-Id: I74730b123ff0b6dfd53396de7be78398b29167e1
---

diff --git a/kernel/arch/arm/boot/dts/qcom/dsi-mipi-2-hdmi_1280p_video.dtsi b/kernel/arch/arm/boot/dts/qcom/dsi-mipi-2-hdmi_1280p_video.dtsi
new file mode 100755
index 0000000..6d94f2d
--- /dev/null
+++ b/kernel/arch/arm/boot/dts/qcom/dsi-mipi-2-hdmi_1280p_video.dtsi
@@ -0,0 +1,75 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*---------------------------------------------------------------------------
+ * This file is autogenerated file using gcdb parser. Please do not edit it.
+ * Update input XML file to add a new entry or update variable in this file
+ * VERSION = "1.0"
+ *---------------------------------------------------------------------------*/
+&mdss_mdp {
+	dsi_mipi_hdmi_1280p_video: qcom,mdss_dsi_mipi_hdmi_1280p_video {
+		qcom,mdss-dsi-panel-name = "lt8912 mipi hdmi 1280p video";
+		qcom,mdss-dsi-panel-controller = <&mdss_dsi0>;
+		qcom,mdss-dsi-panel-type = "dsi_video_mode";
+		qcom,mdss-dsi-panel-destination = "display_1";
+		qcom,mdss-dsi-panel-framerate = <60>;
+		qcom,mdss-dsi-virtual-channel-id = <0>;
+		qcom,mdss-dsi-stream = <0>;
+		qcom,mdss-dsi-panel-width = <1280>;
+		qcom,mdss-dsi-panel-height = <720>;
+		qcom,mdss-dsi-h-front-porch = <110>;
+		qcom,mdss-dsi-h-back-porch = <220>;
+		qcom,mdss-dsi-h-pulse-width = <40>;
+		qcom,mdss-dsi-h-sync-skew = <0>;
+		qcom,mdss-dsi-v-back-porch = <20>;
+		qcom,mdss-dsi-v-front-porch = <5>;
+		qcom,mdss-dsi-v-pulse-width = <5>;
+		qcom,mdss-dsi-h-left-border = <0>;
+		qcom,mdss-dsi-h-right-border = <0>;
+		qcom,mdss-dsi-v-top-border = <0>;
+		qcom,mdss-dsi-v-bottom-border = <0>;
+		qcom,mdss-dsi-bpp = <24>;
+		qcom,mdss-dsi-color-order = "rgb_swap_rgb";
+		qcom,mdss-dsi-underflow-color = <0xff>;
+		qcom,mdss-dsi-border-color = <0>;
+		qcom,mdss-dsi-pixel-packing = "tight";
+		qcom,mdss-dsi-pixel-alignment = <0>;
+		qcom,mdss-command-access = "i2c";
+		qcom,mdss-dsi-on-command = [				
+					05 01 00 00 78 00 02 11 00
+					05 01 00 00 14 00 02 29 00];
+		qcom,mdss-dsi-off-command = [05 01 00 00 32 00 02 28 00
+					05 01 00 00 78 00 02 10 00];
+		qcom,mdss-dsi-on-command-state = "dsi_lp_mode";
+		qcom,mdss-dsi-off-command-state = "dsi_hs_mode";
+		qcom,mdss-dsi-h-sync-pulse = <0>;
+		qcom,mdss-dsi-traffic-mode = "non_burst_sync_event";
+		qcom,mdss-dsi-lane-map = "lane_map_0123";
+		qcom,mdss-dsi-bllp-eof-power-mode;
+		qcom,mdss-dsi-bllp-power-mode;
+		qcom,mdss-dsi-lane-0-state;
+		qcom,mdss-dsi-lane-1-state;
+		qcom,mdss-dsi-lane-2-state;
+		qcom,mdss-dsi-lane-3-state;
+		qcom,mdss-dsi-panel-timings = [7F 1C 12 00 40 44 16 1E 17 03 04 00];
+		qcom,mdss-dsi-t-clk-post = <0x04>;
+		qcom,mdss-dsi-t-clk-pre = <0x27>;
+		qcom,mdss-dsi-bl-min-level = <1>;
+		qcom,mdss-dsi-bl-max-level = <255>;
+		qcom,mdss-dsi-dma-trigger = "trigger_sw";
+		qcom,mdss-dsi-mdp-trigger = "none";
+		qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_pwm";
+		qcom,mdss-dsi-reset-sequence = <1 20>, <0 20>, <1 50>;
+		qcom,mdss-dsi-force-clock-lane-hs;
+		qcom,mdss-dsi-always-on;
+	};
+};
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8916-pinctrl.dtsi b/kernel/arch/arm/boot/dts/qcom/msm8916-pinctrl.dtsi
index 4392ec4..bf05c1a 100755
--- a/kernel/arch/arm/boot/dts/qcom/msm8916-pinctrl.dtsi
+++ b/kernel/arch/arm/boot/dts/qcom/msm8916-pinctrl.dtsi
@@ -137,6 +137,21 @@
 				bias-pull-down;
 			};
 		};
+		/* add lt8912 driver elio shao */
+		lt8912_reset_pin {
+			qcom,pins = <&gp 14>;
+			qcom,pin-func = <0>;
+			qcom,num-grp-pins = <1>;
+			label = "lt8912_reset_pin";
+			lt_default: lt_default {
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+			lt_sleep: lt_sleep {
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+		};
 		cross-conn-det {
 			qcom,pins = <&gp 120>;
 			qcom,num-grp-pins = <1>;
diff --git a/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm755-public.dtsi b/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm755-public.dtsi
index 5b7ef63..e99b72b 100755
--- a/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm755-public.dtsi
+++ b/kernel/arch/arm/boot/dts/qcom/msm8916-qrd-skui-slm755-public.dtsi
@@ -19,6 +19,7 @@
 #include "dsi-panel-hx8394f-720p-video.dtsi"
 #include "dsi-panel-hx8389b-dx050b012-31z12-f-540p-video.dtsi"
 #include "dsi-panel-hx8394f_zzw500hah_720p_video.dtsi"
+#include "dsi-mipi-2-hdmi_1280p_video.dtsi"
 
 &soc {
 	gpio-leds {
@@ -124,7 +125,7 @@
 };
 
 &mdss_dsi0 {
-	qcom,dsi-pref-prim-pan = <&dsi_otm8019a_fwvga_video>;
+	qcom,dsi-pref-prim-pan = <&dsi_mipi_hdmi_1280p_video>;
 	pinctrl-names = "mdss_default", "mdss_sleep";
 	pinctrl-0 = <&mdss_dsi_active>;
 	pinctrl-1 = <&mdss_dsi_suspend>;
@@ -166,6 +167,15 @@
 	qcom,mdss-dsi-bl-pmic-bank-select = <0>;
 	qcom,mdss-dsi-pwm-gpio = <&pm8916_mpps 4 0>;
     qcom,cont-splash-enabled;
+};
+
+/*by eliot shao, 9/13/2016*/
+&dsi_mipi_hdmi_1280p_video {
+    qcom,mdss-dsi-bl-pmic-control-type = "bl_ctrl_pwm";
+	qcom,mdss-dsi-bl-pmic-pwm-frequency = <1000>;
+	qcom,mdss-dsi-bl-pmic-bank-select = <0>;
+	qcom,mdss-dsi-pwm-gpio = <&pm8916_mpps 4 0>;
+    //qcom,cont-splash-enabled;
 };
 
 &dsi_hx8394f_720p_video {
@@ -267,7 +277,15 @@
                 reg = <0x76>;
         };
 // --!>
-
+/*by eliot shao, 9/13/2016*/
+	lt8912 {
+			compatible = "qcom,lt8912";
+			reg = <0x48>;
+			pinctrl-names = "default","sleep";
+            pinctrl-0 = <&lt_default>;
+            pinctrl-1 = <&lt_sleep>;
+			lt,gpio_rstn = <&msm_gpio 14 0x0>;
+	};
 
 // --!>
 /*
diff --git a/kernel/drivers/video/msm/mdss/Makefile b/kernel/drivers/video/msm/mdss/Makefile
old mode 100644
new mode 100755
index a5f4473..191cf7e
--- a/kernel/drivers/video/msm/mdss/Makefile
+++ b/kernel/drivers/video/msm/mdss/Makefile
@@ -13,6 +13,7 @@
 mdss-mdp-objs += mdss_mdp_overlay.o
 mdss-mdp-objs += mdss_mdp_splash_logo.o
 mdss-mdp-objs += mdss_mdp_wb.o
+mdss-mdp-objs += mdss_i2c_interface.o
 obj-$(CONFIG_FB_MSM_MDSS) += mdss-mdp.o
 obj-$(CONFIG_FB_MSM_MDSS) += mdss_mdp_debug.o
 
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi.h b/kernel/drivers/video/msm/mdss/mdss_dsi.h
old mode 100644
new mode 100755
index de1b3c5..d1bb039
--- a/kernel/drivers/video/msm/mdss/mdss_dsi.h
+++ b/kernel/drivers/video/msm/mdss/mdss_dsi.h
@@ -282,6 +282,14 @@
 	DSI_CTRL_MAX,
 };
 
+/*enum that define type of access register default is dsi*/
+enum i2c_cmd_access_type {
+    CMD_ACCESS_DSI,
+    CMD_ACCESS_I2C,
+};
+
+
+
 #define DSI_CTRL_LEFT		DSI_CTRL_0
 #define DSI_CTRL_RIGHT		DSI_CTRL_1
 #define DSI_CTRL_CLK_SLAVE	DSI_CTRL_RIGHT
@@ -349,6 +357,10 @@
 	int bklt_max;
 	int new_fps;
 	int pwm_enabled;
+
+	//add by eliot shao 2016.9.9
+	int cmd_access ;
+	
 	int clk_lane_cnt;
 	bool panel_bias_vreg;
 	bool dsi_irq_line;
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi_host.c b/kernel/drivers/video/msm/mdss/mdss_dsi_host.c
old mode 100644
new mode 100755
index 3442f69..669e23e
--- a/kernel/drivers/video/msm/mdss/mdss_dsi_host.c
+++ b/kernel/drivers/video/msm/mdss/mdss_dsi_host.c
@@ -27,6 +27,7 @@
 #include "mdss_dsi.h"
 #include "mdss_panel.h"
 #include "mdss_debug.h"
+#include "mdss_i2c_interface.h"
 
 #define VSYNC_PERIOD 17
 
@@ -110,8 +111,12 @@
 	mdss_dsi_buf_alloc(ctrl_dev, &ctrl->tx_buf, SZ_4K);
 	mdss_dsi_buf_alloc(ctrl_dev, &ctrl->rx_buf, SZ_4K);
 	mdss_dsi_buf_alloc(ctrl_dev, &ctrl->status_buf, SZ_4K);
-	ctrl->cmdlist_commit = mdss_dsi_cmdlist_commit;
-
+	
+	/*diff two register access type add by eliot shao 2016.9.9*/
+	if (ctrl->cmd_access == CMD_ACCESS_DSI)
+		ctrl->cmdlist_commit = mdss_dsi_cmdlist_commit;
+	else if (ctrl->cmd_access == CMD_ACCESS_I2C)
+		ctrl->cmdlist_commit = mdss_mipi_i2c_init;
 
 	if (dsi_event.inited == 0) {
 		kthread_run(dsi_event_thread, (void *)&dsi_event,
diff --git a/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c b/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c
old mode 100644
new mode 100755
index fb83c75..3412667
--- a/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c
+++ b/kernel/drivers/video/msm/mdss/mdss_dsi_panel.c
@@ -23,6 +23,8 @@
 #include <linux/err.h>
 
 #include "mdss_dsi.h"
+#include "mdss_i2c_interface.h"
+
 
 #define DT_CMD_HDR 6
 
@@ -616,10 +618,15 @@
 		if (ctrl->ndx != DSI_CTRL_LEFT)
 			goto end;
 	}
-
-	if (ctrl->on_cmds.cmd_cnt)
-		mdss_dsi_panel_cmds_send(ctrl, &ctrl->on_cmds);
-
+	
+	if (ctrl->cmd_access == CMD_ACCESS_DSI) {
+	    if (ctrl->on_cmds.cmd_cnt)
+			  mdss_dsi_panel_cmds_send(ctrl, &ctrl->on_cmds);
+	} else if (ctrl->cmd_access == CMD_ACCESS_I2C) {
+    	//add by eliot shao 
+	 	mdss_mipi_i2c_init(ctrl,0);
+  }
+  
 end:
 	pinfo->blank_state = MDSS_PANEL_BLANK_UNBLANK;
 	pr_debug("%s:-\n", __func__);
@@ -1347,6 +1354,7 @@
 	if (data && !strncmp(data, "dsi_cmd_mode", 12))
 		pinfo->mipi.mode = DSI_CMD_MODE;
 	tmp = 0;
+	pinfo->mipi.force_clk_lane_hs = 1;
 	data = of_get_property(np, "qcom,mdss-dsi-pixel-packing", NULL);
 	if (data && !strcmp(data, "loose"))
 		pinfo->mipi.pixel_packing = 1;
@@ -1607,6 +1615,18 @@
 	mdss_dsi_parse_reset_seq(np, pinfo->rst_seq, &(pinfo->rst_seq_len),
 		"qcom,mdss-dsi-reset-sequence");
 
+	//add by eliot shao 2016.9.9 start 
+	rc = of_property_read_string(np,
+          "qcom,mdss-command-access", &data);
+  	if (!rc) {
+	    if (!strcmp(data, "i2c")) {
+	      ctrl_pdata->cmd_access = CMD_ACCESS_I2C;
+
+	    } else   /*normal flow*/
+	       ctrl_pdata->cmd_access = CMD_ACCESS_DSI;
+  	}
+	//add by eliot shao 2016.9.9 end 
+	
 	mdss_dsi_parse_dcs_cmds(np, &ctrl_pdata->on_cmds,
 		"qcom,mdss-dsi-on-command", "qcom,mdss-dsi-on-command-state");
 
@@ -1706,7 +1726,6 @@
 	pinfo->dynamic_switch_pending = false;
 	pinfo->is_lpm_mode = false;
 	pinfo->esd_rdy = false;
-
 	ctrl_pdata->on = mdss_dsi_panel_on;
 	ctrl_pdata->off = mdss_dsi_panel_off;
 	ctrl_pdata->low_power_config = mdss_dsi_panel_low_power_config;
diff --git a/kernel/drivers/video/msm/mdss/mdss_i2c_interface.c b/kernel/drivers/video/msm/mdss/mdss_i2c_interface.c
new file mode 100755
index 0000000..d071157
--- /dev/null
+++ b/kernel/drivers/video/msm/mdss/mdss_i2c_interface.c
@@ -0,0 +1,520 @@
+/*
+*author :shaomingliang (Eliot shao)
+*version:1.0
+*data:2016.9.9
+*function description : an i2c interface for mipi bridge or others i2c slave
+*/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/workqueue.h>
+#include <linux/errno.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+
+#include "mdss_i2c_interface.h"
+#include "mdss_dsi.h"
+
+struct mdss_i2c_interface {
+	unsigned short flags;
+	struct i2c_client *mdss_mipi_i2c_client;
+	unsigned int slave_addr ;
+	struct mutex lock;
+	struct mutex i2c_lock;
+	int gpio_rstn ;
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pin_default;
+	struct pinctrl_state	*pin_sleep;
+};
+
+static struct mdss_i2c_interface *my_mipi_i2c ;
+
+
+/*if I2C_TEST_OK == 1 stand for lt8912's i2c no ack , and the 
+resource of my_mipi_i2c has been remove .must be stop here !
+or will happen null pointer error !
+*/
+
+static int I2C_TEST_OK  = 0 ; //default
+	
+int HDMI_WriteI2C_Byte(int reg, int val)
+{
+	int rc = 0;
+	rc = i2c_smbus_write_byte_data(my_mipi_i2c->mdss_mipi_i2c_client,reg,val);
+	if (rc < 0) {
+		printk("eliot :HDMI_WriteI2C_Byte fail \n");
+        return rc;
+		}
+	return rc ;
+}
+int HDMI_ReadI2C_Byte(int reg)
+{
+	int val = 0;
+	val = i2c_smbus_read_byte_data(my_mipi_i2c->mdss_mipi_i2c_client, reg);
+    if (val < 0) {
+        dev_err(&my_mipi_i2c->mdss_mipi_i2c_client->dev, "i2c read fail: can't read from %02x: %d\n", 0, val);
+        return val;
+    } 
+	return val ;
+}
+
+int Reset_chip(void)
+{
+	// 拉低LT8912 的reset pin，delay 150 ms左右，再拉高
+	gpio_direction_output(my_mipi_i2c->gpio_rstn, 1);
+	mdelay(50);
+
+	gpio_direction_output(my_mipi_i2c->gpio_rstn, 0);
+	mdelay(150);
+
+	gpio_direction_output(my_mipi_i2c->gpio_rstn, 1);
+
+	return 0;
+}
+int test_read(void)
+{
+	int val1=0,val2=0,val3=0;
+	printk("eliot :test_read start \n");
+	mutex_lock(&my_mipi_i2c->i2c_lock);
+	my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x48;
+
+	val1 = i2c_smbus_read_byte_data(my_mipi_i2c->mdss_mipi_i2c_client, 0x00);
+	
+	val2 = i2c_smbus_read_byte_data(my_mipi_i2c->mdss_mipi_i2c_client, 0x01);
+	
+	val3 = i2c_smbus_read_byte_data(my_mipi_i2c->mdss_mipi_i2c_client, 0x55);
+
+	mutex_unlock(&my_mipi_i2c->i2c_lock);
+	printk("eliot :test_read reg0x00:%d,reg0x01:%d,reg0x31:%d\n",val1,val2,val3);
+	return 0 ;
+	
+}
+#ifdef TEST_PATTERN_MODE
+
+static void Test_pattern_720x480(void)
+{
+	my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x49;
+	HDMI_WriteI2C_Byte(0x72,0x12);
+	HDMI_WriteI2C_Byte(0x73,0x7a);//RGD_PTN_DE_DLY[7:0]
+	HDMI_WriteI2C_Byte(0x74,0x00);//RGD_PTN_DE_DLY[11:8]  192
+	HDMI_WriteI2C_Byte(0x75,0x24);//RGD_PTN_DE_TOP[6:0]  41
+	HDMI_WriteI2C_Byte(0x76,0xd0);//RGD_PTN_DE_CNT[7:0]
+	HDMI_WriteI2C_Byte(0x77,0xe0);//RGD_PTN_DE_LIN[7:0]
+	HDMI_WriteI2C_Byte(0x78,0x12);//RGD_PTN_DE_LIN[10:8],RGD_PTN_DE_CNT[11:8]
+	HDMI_WriteI2C_Byte(0x79,0x5a);//RGD_PTN_H_TOTAL[7:0]
+	HDMI_WriteI2C_Byte(0x7a,0x0d);//RGD_PTN_V_TOTAL[7:0]
+	HDMI_WriteI2C_Byte(0x7b,0x23);//RGD_PTN_V_TOTAL[10:8],RGD_PTN_H_TOTAL[11:8]
+	HDMI_WriteI2C_Byte(0x7c,0x3e);//RGD_PTN_HWIDTH[7:0]
+	HDMI_WriteI2C_Byte(0x7d,0x06);//RGD_PTN_HWIDTH[9:8],RGD_PTN_VWIDTH[5:0]
+
+	HDMI_WriteI2C_Byte(0x70,0x80);
+	HDMI_WriteI2C_Byte(0x71,0x17);
+
+	HDMI_WriteI2C_Byte(0x4e,0x66);
+	HDMI_WriteI2C_Byte(0x4f,0x66);
+	HDMI_WriteI2C_Byte(0x50,0x26);
+	HDMI_WriteI2C_Byte(0x51,0x80);
+}
+static void Test_pattern_640x350(void)
+{
+	my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x49;
+	HDMI_WriteI2C_Byte(0x72,0x12);
+	HDMI_WriteI2C_Byte(0x73,0xa0);//RGD_PTN_DE_DLY[7:0]
+	HDMI_WriteI2C_Byte(0x74,0x00);//RGD_PTN_DE_DLY[11:8]  192
+	HDMI_WriteI2C_Byte(0x75,0x3f);//RGD_PTN_DE_TOP[6:0]  41
+	HDMI_WriteI2C_Byte(0x76,0x80);//RGD_PTN_DE_CNT[7:0]
+	HDMI_WriteI2C_Byte(0x77,0x5e);//RGD_PTN_DE_LIN[7:0]
+	HDMI_WriteI2C_Byte(0x78,0x12);//RGD_PTN_DE_LIN[10:8],RGD_PTN_DE_CNT[11:8]
+	HDMI_WriteI2C_Byte(0x79,0x40);//RGD_PTN_H_TOTAL[7:0]
+	HDMI_WriteI2C_Byte(0x7a,0xbd);//RGD_PTN_V_TOTAL[7:0]
+	HDMI_WriteI2C_Byte(0x7b,0x13);//RGD_PTN_V_TOTAL[10:8],RGD_PTN_H_TOTAL[11:8]
+	HDMI_WriteI2C_Byte(0x7c,0x40);//RGD_PTN_HWIDTH[7:0]
+	HDMI_WriteI2C_Byte(0x7d,0x3);//RGD_PTN_HWIDTH[9:8],RGD_PTN_VWIDTH[5:0]
+
+	HDMI_WriteI2C_Byte(0x70,0x80);
+	HDMI_WriteI2C_Byte(0x71,0x17);
+
+	HDMI_WriteI2C_Byte(0x4e,0x66);
+	HDMI_WriteI2C_Byte(0x4f,0x66);
+	HDMI_WriteI2C_Byte(0x50,0x26);
+	HDMI_WriteI2C_Byte(0x51,0x80);
+}
+static void Test_pattern_1280x720(void)
+{
+	my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x49;
+	HDMI_WriteI2C_Byte(0x72,0x12);
+	HDMI_WriteI2C_Byte(0x73,0x04);//RGD_PTN_DE_DLY[7:0]
+	HDMI_WriteI2C_Byte(0x74,0x01);//RGD_PTN_DE_DLY[11:8]  192
+	HDMI_WriteI2C_Byte(0x75,0x19);//RGD_PTN_DE_TOP[6:0]  41
+	HDMI_WriteI2C_Byte(0x76,0x00);//RGD_PTN_DE_CNT[7:0]
+	HDMI_WriteI2C_Byte(0x77,0xD0);//RGD_PTN_DE_LIN[7:0]
+	HDMI_WriteI2C_Byte(0x78,0x25);//RGD_PTN_DE_LIN[10:8],RGD_PTN_DE_CNT[11:8]
+	HDMI_WriteI2C_Byte(0x79,0x72);//RGD_PTN_H_TOTAL[7:0]
+	HDMI_WriteI2C_Byte(0x7a,0xEE);//RGD_PTN_V_TOTAL[7:0]
+	HDMI_WriteI2C_Byte(0x7b,0x26);//RGD_PTN_V_TOTAL[10:8],RGD_PTN_H_TOTAL[11:8]
+	HDMI_WriteI2C_Byte(0x7c,0x28);//RGD_PTN_HWIDTH[7:0]
+	HDMI_WriteI2C_Byte(0x7d,0x05);//RGD_PTN_HWIDTH[9:8],RGD_PTN_VWIDTH[5:0]
+
+	HDMI_WriteI2C_Byte(0x70,0x80);
+	HDMI_WriteI2C_Byte(0x71,0x17);
+
+	HDMI_WriteI2C_Byte(0x4e,0x93);
+	HDMI_WriteI2C_Byte(0x4f,0x3E);
+	HDMI_WriteI2C_Byte(0x50,0x69);
+	HDMI_WriteI2C_Byte(0x51,0x80);
+}
+
+#endif
+
+/*This function para Get from FAE*/
+int mdss_mipi_i2c_init(struct mdss_dsi_ctrl_pdata *ctrl, int from_mdp)
+{
+	printk("eliot :mdss_mipi_i2c_init start \n");
+	//Reset_chip();
+	/*if I2C_TEST_OK == 1 stand for lt8912's i2c no ack , and the 
+	resource of my_mipi_i2c has been remove .must be stop here !
+	*/
+	if(I2C_TEST_OK  == 1)
+		return 0;
+	// 往LT8912寄存器写值：
+	//******************************************//
+		mutex_lock(&my_mipi_i2c->i2c_lock);
+	//	DigitalClockEn();
+		my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x48; // IIC address
+		HDMI_WriteI2C_Byte(0x08,0xff);// Register address : 0x08;	Value : 0xff
+		HDMI_WriteI2C_Byte(0x09,0xff);
+		HDMI_WriteI2C_Byte(0x0a,0xff);
+		HDMI_WriteI2C_Byte(0x0b,0xff);
+		HDMI_WriteI2C_Byte(0x0c,0xff);
+	
+	//******************************************//
+	
+	//	TxAnalog();
+		my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x48;
+		HDMI_WriteI2C_Byte(0x31,0xa1);
+		HDMI_WriteI2C_Byte(0x32,0xa1);
+		HDMI_WriteI2C_Byte(0x33,0x03);
+		HDMI_WriteI2C_Byte(0x37,0x00);
+		HDMI_WriteI2C_Byte(0x38,0x22);
+		HDMI_WriteI2C_Byte(0x60,0x82);
+	
+	//******************************************//
+	
+	//	CbusAnalog();
+		my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x48;
+		HDMI_WriteI2C_Byte(0x39,0x45);
+		HDMI_WriteI2C_Byte(0x3b,0x00);
+	
+	//******************************************//
+	
+	//	HDMIPllAnalog();
+		my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x48;
+		HDMI_WriteI2C_Byte(0x44,0x31);
+		HDMI_WriteI2C_Byte(0x55,0x44);
+		HDMI_WriteI2C_Byte(0x57,0x01);
+		HDMI_WriteI2C_Byte(0x5a,0x02);
+	
+	//******************************************//
+	
+	//	MipiBasicSet();
+		my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x49;
+		HDMI_WriteI2C_Byte(0x10,0x20);	
+		HDMI_WriteI2C_Byte(0x11,0x04);	
+		HDMI_WriteI2C_Byte(0x12,0x04);	
+		HDMI_WriteI2C_Byte(0x13,0x00);	// 00 4 lane  // 01 lane // 02 2 lane //03 3 lane
+		HDMI_WriteI2C_Byte(0x14,0x00);	
+		HDMI_WriteI2C_Byte(0x15,0x00);
+		HDMI_WriteI2C_Byte(0x1a,0x03);	
+		HDMI_WriteI2C_Byte(0x1b,0x03);	
+	
+	//******************************************//
+	
+	//	MIPIDig1280x720();
+		my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x49;
+		HDMI_WriteI2C_Byte(0x18,0x28); // hwidth
+		HDMI_WriteI2C_Byte(0x19,0x05); // vwidth 6
+		HDMI_WriteI2C_Byte(0x1c,0x00); // H_active[7:0]
+		HDMI_WriteI2C_Byte(0x1d,0x05); // H_active[15:8]
+		HDMI_WriteI2C_Byte(0x1e,0x67); // hs/vs/de pol hdmi sel pll sel
+		HDMI_WriteI2C_Byte(0x2f,0x0c); // fifo_buff_length 12
+		HDMI_WriteI2C_Byte(0x34,0x72); // H_total[7:0]
+		HDMI_WriteI2C_Byte(0x35,0x06); // H_total[15:8]
+		HDMI_WriteI2C_Byte(0x36,0xEE); // V_total[7:0]
+		HDMI_WriteI2C_Byte(0x37,0x02); // V_total[15:8]
+		HDMI_WriteI2C_Byte(0x38,0x14); // VBP[7:0]
+		HDMI_WriteI2C_Byte(0x39,0x00); // VBP[15:8]
+		HDMI_WriteI2C_Byte(0x3a,0x05); // VFP[7:0]
+		HDMI_WriteI2C_Byte(0x3b,0x00); // VFP[15:8]
+		HDMI_WriteI2C_Byte(0x3c,0xDC); // HBP[7:0]
+		HDMI_WriteI2C_Byte(0x3d,0x00); // HBP[15:8]
+		HDMI_WriteI2C_Byte(0x3e,0x6E); // HFP[7:0]
+		HDMI_WriteI2C_Byte(0x3f,0x00); // HFP[15:8]
+
+
+
+	
+	//******************************************//
+	
+	//	DDSConfig();
+		my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x49;
+		HDMI_WriteI2C_Byte(0x4e,0x93);
+		HDMI_WriteI2C_Byte(0x4f,0x3E);
+		HDMI_WriteI2C_Byte(0x50,0x69);
+
+		HDMI_WriteI2C_Byte(0x51,0x80);
+		HDMI_WriteI2C_Byte(0x1f,0x90);
+		HDMI_WriteI2C_Byte(0x20,0x01);
+		HDMI_WriteI2C_Byte(0x21,0x68);
+		HDMI_WriteI2C_Byte(0x22,0x01);
+		HDMI_WriteI2C_Byte(0x23,0x5E);
+		HDMI_WriteI2C_Byte(0x24,0x01);
+		HDMI_WriteI2C_Byte(0x25,0x54);
+		HDMI_WriteI2C_Byte(0x26,0x01);
+		HDMI_WriteI2C_Byte(0x27,0x90);
+		HDMI_WriteI2C_Byte(0x28,0x01);
+		HDMI_WriteI2C_Byte(0x29,0x68);
+		HDMI_WriteI2C_Byte(0x2a,0x01);
+		HDMI_WriteI2C_Byte(0x2b,0x5E);
+		HDMI_WriteI2C_Byte(0x2c,0x01);
+		HDMI_WriteI2C_Byte(0x2d,0x54);
+		HDMI_WriteI2C_Byte(0x2e,0x01);
+		HDMI_WriteI2C_Byte(0x42,0x64);
+		HDMI_WriteI2C_Byte(0x43,0x00);
+		HDMI_WriteI2C_Byte(0x44,0x04);
+		HDMI_WriteI2C_Byte(0x45,0x00);
+		HDMI_WriteI2C_Byte(0x46,0x59);
+		HDMI_WriteI2C_Byte(0x47,0x00);
+		HDMI_WriteI2C_Byte(0x48,0xf2);
+		HDMI_WriteI2C_Byte(0x49,0x06);
+		HDMI_WriteI2C_Byte(0x4a,0x00);
+		HDMI_WriteI2C_Byte(0x4b,0x72);
+		HDMI_WriteI2C_Byte(0x4c,0x45);
+		HDMI_WriteI2C_Byte(0x4d,0x00);
+		HDMI_WriteI2C_Byte(0x52,0x08);
+		HDMI_WriteI2C_Byte(0x53,0x00);
+		HDMI_WriteI2C_Byte(0x54,0xb2);
+		HDMI_WriteI2C_Byte(0x55,0x00);
+		HDMI_WriteI2C_Byte(0x56,0xe4);
+		HDMI_WriteI2C_Byte(0x57,0x0d);
+		HDMI_WriteI2C_Byte(0x58,0x00);
+		HDMI_WriteI2C_Byte(0x59,0xe4);
+		HDMI_WriteI2C_Byte(0x5a,0x8a);
+		HDMI_WriteI2C_Byte(0x5b,0x00);
+		HDMI_WriteI2C_Byte(0x5c,0x34);
+		HDMI_WriteI2C_Byte(0x1e,0x4f);
+		HDMI_WriteI2C_Byte(0x51,0x00);
+	
+	//******************************************//
+	
+	//	AudioIIsEn();
+		my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x48;
+		HDMI_WriteI2C_Byte(0xB2,0x01);
+		my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x4a;
+		HDMI_WriteI2C_Byte(0x06,0x08);
+		HDMI_WriteI2C_Byte(0x07,0xF0);
+		HDMI_WriteI2C_Byte(0x34,0xD2);
+		
+	
+	//******************************************//
+	
+	//	MIPIRxLogicRes();
+		my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x48;
+		HDMI_WriteI2C_Byte(0x03,0x7f);
+		mdelay(100);
+		HDMI_WriteI2C_Byte(0x03,0xff);
+	
+	//******************************************//
+#ifdef TEST_PATTERN_MODE
+
+	Test_pattern_1280x720();
+
+#endif
+
+	mutex_unlock(&my_mipi_i2c->i2c_lock);
+
+	printk("eliot :mdss_mipi_i2c_init end \n");
+	return 0 ;
+	
+}
+
+EXPORT_SYMBOL_GPL(mdss_mipi_i2c_init);
+
+static int lt_pinctrl_init(struct mdss_i2c_interface *lt)
+{
+	struct i2c_client *client = lt->mdss_mipi_i2c_client;
+
+	lt->pinctrl = devm_pinctrl_get(&client->dev);
+	if (IS_ERR_OR_NULL(lt->pinctrl)) {
+		dev_err(&client->dev, "Failed to get pinctrl\n");
+		return PTR_ERR(lt->pinctrl);
+	}
+
+	lt->pin_default = pinctrl_lookup_state(lt->pinctrl, "default");
+	if (IS_ERR_OR_NULL(lt->pin_default)) {
+		dev_err(&client->dev, "Failed to look up default state\n");
+		return PTR_ERR(lt->pin_default);
+	}
+
+	lt->pin_sleep = pinctrl_lookup_state(lt->pinctrl, "sleep");
+	if (IS_ERR_OR_NULL(lt->pin_sleep)) {
+		dev_err(&client->dev, "Failed to look up sleep state\n");
+		return PTR_ERR(lt->pin_sleep);
+	}
+
+	return 0;
+}
+
+/*
+	1.get reset pin and request gpio ;
+	2.get i2c client ,check i2c function and test read i2c slave ;
+	3.send lt8912 i2c configuration table
+*/
+static int mipi_i2c_probe(struct i2c_client *client,
+        const struct i2c_device_id *id) 
+{
+    int err;
+	struct mdss_dsi_ctrl_pdata *ctrl=NULL;
+	int from_mdp=0 ;
+
+	printk("eliot :mipi_i2c_probe start.....");
+	
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev,
+				"%s: check_functionality failed.", __func__);
+		err = -ENODEV;
+		goto exit0;
+	}
+
+	/* Allocate memory for driver data */
+	my_mipi_i2c = kzalloc(sizeof(struct mdss_i2c_interface), GFP_KERNEL);
+	if (!my_mipi_i2c) {
+		dev_err(&client->dev,
+				"%s: memory allocation failed.", __func__);
+		err = -ENOMEM;
+		goto exit1;
+	}
+	
+	mutex_init(&my_mipi_i2c->lock);
+	mutex_init(&my_mipi_i2c->i2c_lock);
+
+	if (client->dev.of_node) {
+	my_mipi_i2c->gpio_rstn = of_get_named_gpio_flags(client->dev.of_node,
+			"lt,gpio_rstn", 0, NULL);
+	//printk("eliot:my_mipi_i2c->gpio_rstn=%d\n",my_mipi_i2c->gpio_rstn);
+	}
+	else
+	{
+		printk("eliot:client->dev.of_node not exit!\n");
+	}
+
+	/***** I2C initialization *****/
+	my_mipi_i2c->mdss_mipi_i2c_client = client;
+	
+	/* set client data */
+	i2c_set_clientdata(client, my_mipi_i2c);
+
+	/* initialize pinctrl */
+	if (!lt_pinctrl_init(my_mipi_i2c)) {
+		err = pinctrl_select_state(my_mipi_i2c->pinctrl, my_mipi_i2c->pin_default);
+		if (err) {
+			dev_err(&client->dev, "Can't select pinctrl state\n");
+			goto exit2;
+		}
+	}
+	mutex_lock(&my_mipi_i2c->lock);
+
+	/* Pull up the reset pin */
+	/* request  GPIO  */
+	err = gpio_request(my_mipi_i2c->gpio_rstn, "lt8912_rsrn");
+	if (err < 0) {
+		mutex_unlock(&my_mipi_i2c->lock);
+		printk("Failed to request GPIO:%d, ERRNO:%d",
+			  my_mipi_i2c->gpio_rstn, err);
+		err = -ENODEV;
+	}else{
+		gpio_direction_output(my_mipi_i2c->gpio_rstn, 0);
+		mdelay(250);
+		gpio_direction_output(my_mipi_i2c->gpio_rstn, 1);
+
+		}
+	my_mipi_i2c->mdss_mipi_i2c_client->addr = 0x48;
+    err = i2c_smbus_read_byte_data(client, 0x08);
+    if (err < 0) {
+		I2C_TEST_OK = 1 ;
+		mutex_unlock(&my_mipi_i2c->lock);
+		gpio_direction_output(my_mipi_i2c->gpio_rstn, 0);
+		dev_err(&client->dev, "i2c read fail: can't read from %02x: %d\n", 0, err);
+        goto exit3;
+    } 
+	mdss_mipi_i2c_init(ctrl,from_mdp);
+	//test_read();
+	mutex_unlock(&my_mipi_i2c->lock);
+	printk("eliot :mipi_i2c_probe end ....\n");
+	return 0;
+exit3:
+	gpio_free(my_mipi_i2c->gpio_rstn);
+exit2:
+	kfree(my_mipi_i2c);
+exit1:
+exit0:
+	return err;
+
+}
+
+static const struct of_device_id mipi_i2c_of_match[] = {
+    { .compatible = "qcom,lt8912",},
+    {},
+};
+
+static const struct i2c_device_id mipi_i2c_id[] = {
+    {"qcom,lt8912", 0},
+    {},
+};
+static int mipi_i2c_resume(struct device *tdev) {
+	Reset_chip();
+    return 0;
+}
+
+static int mipi_i2c_remove(struct i2c_client *client) {
+	
+    return 0;
+}
+
+static int mipi_i2c_suspend(struct device *tdev) {
+	gpio_direction_output(my_mipi_i2c->gpio_rstn, 0);
+    return 0;
+}
+
+static const struct dev_pm_ops mipi_i2c_pm_ops =
+{ 
+    .suspend = mipi_i2c_suspend,
+    .resume = mipi_i2c_resume, 
+};
+
+
+static struct i2c_driver mipi_i2c_driver = {
+    .driver = {
+        .name = "qcom,lt8912",
+        .owner    = THIS_MODULE,
+        .of_match_table = mipi_i2c_of_match,
+        .pm = &mipi_i2c_pm_ops,
+    },
+    .probe    = mipi_i2c_probe,
+    .remove   = mipi_i2c_remove,
+    .id_table = mipi_i2c_id,
+};
+
+module_i2c_driver(mipi_i2c_driver);
+
+MODULE_LICENSE("GPL");
+
diff --git a/kernel/drivers/video/msm/mdss/mdss_i2c_interface.h b/kernel/drivers/video/msm/mdss/mdss_i2c_interface.h
new file mode 100755
index 0000000..6a618bd
--- /dev/null
+++ b/kernel/drivers/video/msm/mdss/mdss_i2c_interface.h
@@ -0,0 +1,6 @@
+#include "mdss_dsi.h"
+
+//int mdss_mipi_i2c_init(void);
+int mdss_mipi_i2c_init(struct mdss_dsi_ctrl_pdata *ctrl, int from_mdp);
+
+
